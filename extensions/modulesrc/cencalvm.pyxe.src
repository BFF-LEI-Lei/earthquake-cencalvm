#!/usr/bin/env python
#
# ======================================================================
#
#                           Brad T. Aagaard
#                        U.S. Geological Survey
#
# {LicenseText}
#
# ======================================================================
#

#header{
#include "CenCalVMDB.h"

#include <stdexcept>
#include <Python.h>
#}header

# ----------------------------------------------------------------------
cdef extern from "Python.h":
  object PyCObject_FromVoidPtr(void*, void (*destruct)(void*))
  void* PyCObject_AsVoidPtr(object)


cdef extern from "stdlib.h":
  ctypedef unsigned long size_t
  void* malloc(size_t size)
  void free(void* mem)
  void strcpy(char*, char*)


cdef void* ptrFromHandle(obj):
  """
  Extract pointer from PyCObject.
  """
  return PyCObject_AsVoidPtr(obj.handle)

# ----------------------------------------------------------------------
cdef void SpatialDB_destructor(void* obj):
  """
  Destroy SpatialDB object.
  """
  # create shim for destructor
  #embed{ void SpatialDB_destructor_cpp(void* pObj)
  spatialdata::spatialdb::SpatialDB* pDB =
    (spatialdata::spatialdb::SpatialDB*) pObj;
  delete pDB;
  #}embed
  SpatialDB_destructor_cpp(obj)
  return

cdef class SpatialDB:

  cdef void* thisptr # Pointer to C++ object
  cdef readonly object handle # PyCObject holding pointer to C++ object
  cdef readonly object name # Identifier for type of object

  def __init__(self):
    """
    Constructor.
    """
    self.handle = None
    self.thisptr = NULL
    self.name = "spatialdata_spatialdb_SpatialDB"
    return


  property label:
    def __set__(self, name):
      """
      Set label of spatial database.
      """
      # create shim for method 'label'
      #embed{ void SpatialDB_label_set(void* pObj, char* name)
      try {
        ((spatialdata::spatialdb::SpatialDB*) pObj)->label(name);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      #}embed

      SpatialDB_label_set(self.thisptr, name)

    def __get__(self):
      """
      Get label of spatial database.
      """
      # create shim for method 'label'
      #embed{ char* SpatialDB_label_get(void* pObj)
      char* label = 0;
      try {
        label = (char*) ((spatialdata::spatialdb::SpatialDB*) pObj)->label();
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch
      return label;
      #}embed

      return SpatialDB_label_get(self.thisptr)

      
  def open(self):
    """
    Open database and prepare for querying.
    """
    # create shim for method 'open'
    #embed{ void SpatialDB_open(void* pObj)
    try {
      ((spatialdata::spatialdb::SpatialDB*) pObj)->open();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed

    SpatialDB_open(self.thisptr)
    return


  def close(self):
    """
    Close the database.
    """
    # create shim for method 'close'
    #embed{ void SpatialDB_close(void* pObj)
    try {
      ((spatialdata::spatialdb::SpatialDB*) pObj)->close();
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed

    SpatialDB_close(self.thisptr)
    return


  def queryVals(self, names):
    """
    Set values to be returned by queries.
    """
    # create shim for method 'queryVals'
    #embed{ void SpatialDB_queryVals(void* pObj, char** names, int numVals)
    try {
      ((spatialdata::spatialdb::SpatialDB*) pObj)->queryVals((const char**) names, numVals);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    #}embed

    cdef char** pNames
    pNames = NULL
    numVals = len(names)
    if numVals > 0:
      pNames = <char**> malloc(numVals*sizeof(char*))
    for i from 0 <= i < numVals:
      strsize = len(names[i])
      pNames[i] = <char*> malloc(1+strsize*sizeof(char))
      tmp = names[i]
      strcpy(pNames[i], tmp)

    SpatialDB_queryVals(self.thisptr, pNames, numVals)

    # memory cleanup
    for i from 0 <= i < numVals:
      free(<void*> pNames[i])
    free(<void*> pNames)
    
    return


  def query(self, locs, cs, nvals):
    """
    Query db to get values at locations.
    """
    # create shim for method 'query'
    #embed{ int SpatialDB_query(void* pObj, double* vals, int nvals, double* coords, int spaceDim, void* csObj)
    int err = 0;
    try {
      spatialdata::geocoords::CoordSys* pCS =
        (spatialdata::geocoords::CoordSys*) csObj;
        err = ((spatialdata::spatialdb::SpatialDB*) pObj)->query(vals, nvals,
                                                            coords, spaceDim,
                                                            pCS);
    } catch (const std::exception& err) {
      PyErr_SetString(PyExc_RuntimeError,
                      const_cast<char*>(err.what()));
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Caught unknown C++ exception.");
    } // try/catch
    return err;
    #}embed

    import spatialdata.utils.simplearray
    locs = spatialdata.utils.simplearray.objAsSimpleArray(locs)
    if not locs.isCompatible(nd=2,
                             simpletype="double",
                             contiguous=True,
                             notswapped=True):
      raise TypeError, \
            "Argument 'locs' must be a contiguous, 2-D array of type double."

    if not cs.name == "spatialdata_geocoords_CoordSys":
      raise TypeError, \
            "Argument 'cs' must be extension module type 'CoordSys'."
    if nvals < 1:
      raise TypeError, \
              "Argument 'nvals' must be a positive integer."

    (nlocs, spaceDim) = locs.shape
    
    cdef double* pLocs
    pLocs = <double*> PyCObject_AsVoidPtr(locs.data)

    cdef double* pVals
    pVals = <double*> malloc(nlocs*nvals*sizeof(double))

    cdef int* pErr
    pErr = <int*> malloc(nlocs*sizeof(int))

    cdef double* valbuffer
    valbuffer = <double*> malloc(nvals*sizeof(double))

    for iloc from 0 <= iloc < nlocs:
      pErr[iloc] = SpatialDB_query(self.thisptr, valbuffer, nvals,
                                  &pLocs[spaceDim*iloc], spaceDim,
                                  ptrFromHandle(cs))
      for ival from 0 <= ival < nvals:
        pVals[nvals*iloc+ival] = valbuffer[ival]
    free(<void*> valbuffer)

    dims = [nlocs, nvals]
    import spatialdata.utils.simplearray
    pValsObj = PyCObject_FromVoidPtr(pVals, NULL);
    pErrObj = PyCObject_FromVoidPtr(pErr, NULL);
    return (spatialdata.utils.simplearray.SimpleCppArray(pValsObj, dims, "double"),
            spatialdata.utils.simplearray.SimpleCppArray(pErrObj, [nlocs], "int"))


  def _createHandle(self):
    """
    Wrap pointer to C++ object in PyCObject.
    """
    return PyCObject_FromVoidPtr(self.thisptr, SpatialDB_destructor)


# ----------------------------------------------------------------------
cdef class CenCalVMDB(SpatialDB):

  def __init__(self):
    """
    Constructor.
    """
    # create shim for constructor
    #embed{ void* CenCalVMDB_constructor()
      return (void*)(new cencalvm::extensions::cencalvmdb::CenCalVMDB);
    #}embed
    SpatialDB.__init__(self)
    self.thisptr = CenCalVMDB_constructor()
    self.handle = self._createHandle()
    return


  property queryType:
    def __set__(self, value):
      """
      Set query type.
      """
      # create shim for method 'queryType'
      #embed{ void CenCalVMDB_queryType_set(void* pObj, char* value)
      try {
        cencalvm::query::VMQuery::QueryEnum queryType =
          cencalvm::query::VMQuery::MAXRES;
        if (0 == strcasecmp(value, "maxres"))
          queryType = cencalvm::query::VMQuery::MAXRES;
        else if (0 == strcasecmp(value, "fixedres"))
          queryType = cencalvm::query::VMQuery::FIXEDRES;
        else if (0 == strcasecmp(value, "waveres"))
          queryType = cencalvm::query::VMQuery::WAVERES;
        ((cencalvm::extensions::cencalvmdb::CenCalVMDB*) pObj)->queryType(queryType);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch        
      #}embed
      CenCalVMDB_queryType_set(self.thisptr, value)


  property queryRes:
    def __set__(self, value):
      """
      Set query resolution.
      """
      # create shim for method 'queryRes'
      #embed{ void CenCalVMDB_queryRes_set(void* pObj, float value)
      try {
        ((cencalvm::extensions::cencalvmdb::CenCalVMDB*) pObj)->queryRes(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch        
      #}embed
      CenCalVMDB_queryRes_set(self.thisptr, value)


  property filename:
    def __set__(self, value):
      """
      Set filename for database.
      """
      # create shim for method 'filename'
      #embed{ void CenCalVMDB_filename_set(void* pObj, char* value)
      try {
        ((cencalvm::extensions::cencalvmdb::CenCalVMDB*) pObj)->filename(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch        
      #}embed
      CenCalVMDB_filename_set(self.thisptr, value)


  property cacheSize:
    def __set__(self, value):
      """
      Set cache size for database.
      """
      # create shim for method 'cacheSize'
      #embed{ void CenCalVMDB_cacheSize_set(void* pObj, int value)
      try {
        ((cencalvm::extensions::cencalvmdb::CenCalVMDB*) pObj)->cacheSize(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch        
      #}embed
      CenCalVMDB_cacheSize_set(self.thisptr, value)


  property filenameExt:
    def __set__(self, value):
      """
      Set filename for extended database.
      """
      # create shim for method 'filenameExt'
      #embed{ void CenCalVMDB_filenameExt_set(void* pObj, char* value)
      try {
        ((cencalvm::extensions::cencalvmdb::CenCalVMDB*) pObj)->filenameExt(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch        
      #}embed
      CenCalVMDB_filenameExt_set(self.thisptr, value)


  property cacheSizeExt:
    def __set__(self, value):
      """
      Set cache size for extended database.
      """
      # create shim for method 'cacheSizeExt'
      #embed{ void CenCalVMDB_cacheSizeExt_set(void* pObj, int value)
      try {
        ((cencalvm::extensions::cencalvmdb::CenCalVMDB*) pObj)->cacheSizeExt(value);
      } catch (const std::exception& err) {
        PyErr_SetString(PyExc_RuntimeError,
                        const_cast<char*>(err.what()));
      } catch (...) {
        PyErr_SetString(PyExc_RuntimeError,
                        "Caught unknown C++ exception.");
      } // try/catch        
      #}embed
      CenCalVMDB_cacheSizeExt_set(self.thisptr, value)


# End of file 
